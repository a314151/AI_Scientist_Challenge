# 约束提取与过滤实现方案

## 概述

本文档详细说明了litLLMs系统中约束提取、硬编码过滤约束条件、约束传递给后续agent以及文献检索API层面优化的完整实现方案。

---

## 1. 增强的约束提取 (parse_user_prompt)

### 1.1 新增提取的约束类型

系统增强了 `parse_user_prompt` 函数，能够从用户输入中提取多种类型的约束条件：

#### 时间约束
- **支持模式**：`since`/`after`/`from`/`before`/`in`/`during`/`between`
- **提取格式**：
  - `since 2020` / `after 2020` / `from 2020` → `time_constraint_type: 'since'`, `time_constraint: '2020'`
  - `before 2020` → `time_constraint_type: 'before'`, `time_constraint: '2020'`
  - `in 2020` / `during 2020` → `time_constraint_type: 'in'`, `time_constraint: '2020'`
  - `between 2020 and 2023` → `time_constraint_type: 'between'`, `time_range: ('2020', '2023')`
- **月份支持**：支持 `YYYY-MM-DD`、`YYYY-MM`、`Month YYYY`、`YYYY` 等多种日期格式

#### 语言要求
- **提取关键词**：`in english`、`english only`、`中文`、`chinese` 等
- **存储格式**：`language: 'english'` 或 `language: 'chinese'`

#### 论文类型
- **提取关键词**：`journal`、`conference`、`preprint`、`workshop` 等
- **存储格式**：`paper_type: 'journal'` 或 `paper_type: 'conference'`

#### 重点关注领域
- **提取关键词**：`focus on`、`particularly`、`especially`、`mainly` 等
- **存储格式**：`focus_areas: ['area1', 'area2', ...]`

#### 排除词
- **提取关键词**：`not`、`exclude`、`avoid`、`without` 等
- **存储格式**：`exclude_terms: ['term1', 'term2', ...]`

#### 最小引用数
- **提取模式**：`at least X citations`、`minimum X citations`、`X+ citations`
- **存储格式**：`min_citations: X`

#### 特殊要求
- **提取关键词**：`systematic`、`critical`、`comprehensive`、`detailed` 等
- **存储格式**：`special_requirements: ['systematic', 'critical', ...]`

---

## 2. 硬编码过滤 (filter_papers_by_constraints)

### 2.1 实现原理

在检索完成后，使用硬编码逻辑直接过滤论文，确保只有符合约束条件的论文进入后续处理流程。

### 2.2 过滤类型

#### 年份过滤
根据 `time_constraint_type` 和 `time_constraint` 进行硬编码过滤：

```python
# since/after/from YYYY: 保留该年份及之后
if time_constraint_type in ['since', 'after', 'from']:
    保留论文 if paper_year >= constraint_year

# before YYYY: 保留该年份之前
if time_constraint_type == 'before':
    保留论文 if paper_year < constraint_year

# in/during YYYY: 仅保留该年份
if time_constraint_type in ['in', 'during']:
    保留论文 if paper_year == constraint_year

# between YYYY and YYYY: 保留范围内
if time_constraint_type == 'between':
    保留论文 if start_year <= paper_year <= end_year
```

**日期解析**：
- 使用 `parse_date_with_month()` 函数解析各种日期格式
- 支持 `YYYY-MM-DD`、`YYYY-MM`、`Month YYYY`、`YYYY` 等格式
- 对于月份信息，进行精确匹配（如果提供）

#### 引用数过滤
- **条件**：如果 `min_citations` 存在
- **逻辑**：`保留论文 if paper.citation_count >= min_citations`
- **处理**：对于引用数为 0 或未知的论文，一般直接舍弃

#### 排除词过滤
- **条件**：如果 `exclude_terms` 存在
- **逻辑**：
  - 检查论文标题和摘要
  - 使用词边界匹配（`\b`）避免部分匹配
  - 排除包含任何排除词的论文

### 2.3 过滤后检查

系统会检查过滤结果：
- **自动重试机制**：如果过滤后论文过少，自动放宽部分约束（如降低最小引用数、移除部分排除词）并重新过滤

---

## 3. 约束传递到生成 Agent

### 3.1 约束转换 (requirements_text)

在 `generate_plan` 和 `generate_review` 函数中，将提取的约束转换为 `requirements_text`：

```python
requirements_text = ""

# 时间约束
if time_constraint:
    requirements_text += f"- Time constraint: {time_constraint_type} {time_constraint}\n"

# 特殊要求
if special_requirements:
    for req in special_requirements:
        if 'systematic' in req:
            requirements_text += "- MUST provide systematic analysis\n"
        if 'critical' in req:
            requirements_text += "- MUST include critical analysis\n"

# 重点关注领域
if focus_areas:
    requirements_text += f"- MUST particularly focus on: {', '.join(focus_areas)}\n"

# 语言要求
if language:
    requirements_text += f"- Language requirement: {language}\n"

# 论文类型
if paper_type:
    requirements_text += f"- Paper type: Prefer {paper_type} papers\n"

# 最小引用数（已在过滤阶段处理，这里仅作为提示）
if min_citations:
    requirements_text += f"- Citation requirement: Papers should have at least {min_citations} citations\n"
```

### 3.2 Prompt 集成

将 `requirements_text` 插入到 LLM 的 prompt 中：

- **Plan 生成**：在 `CRITICAL REQUIREMENTS` 部分包含约束
- **Review 生成**：在 `MUST address the specific requirements` 部分包含约束
- **效果**：LLM 在生成内容时会考虑这些约束，进行软过滤和内容调整

### 3.3 引用数量强化

为确保生成约 50 个引用(这里的50个引用可以灵活调节，设置为50个是因为考虑到prompt里面的约束条件，检索到的论文会变少，可利用的论文也相应降低，为了保证综述质量所以暂时在prompt层面要求引用到50篇论文)，系统在 prompt 中多次强调：

- **Plan Prompt**：
  - `MUST cite EXACTLY 50 references (NOT fewer)`
  - `A citation distribution plan: Section 1 will cite X references, Section 2 will cite Y references, Section 3 will cite Z references, where X+Y+Z = 50`
  
- **Review Prompt**：
  - `ABSOLUTELY MANDATORY: MUST cite EXACTLY 50 references - NOT 30, NOT 40, but 50`
  - `Count your citations as you write: you need 50 different citations`
  - `If you have cited fewer than 50 references, you MUST add more citations until you reach 50`

---

## 4. API 层面优化

### 4.1 年份参数提取

在 `search_multiple_sources` 函数中：

```python
# 从约束中提取年份用于API查询
query_publication_date = None
if constraints:
    time_constraint = constraints.get('time_constraint')
    time_constraint_type = constraints.get('time_constraint_type')
    if time_constraint and time_constraint_type in ['since', 'after', 'from']:
        # 对于since/after/from，使用该年份作为查询参数
        query_publication_date = time_constraint
```

### 4.2 API 调用优化

#### OpenAlex API
- **参数传递**：将 `query_publication_date` 传递给 `get_openalex_candidates()`
- **效果**：在 API 层面即应用年份过滤，减少不相关论文的检索

#### 其他数据源
- **arXiv**：不支持年份参数，依赖后续硬编码过滤
- **CrossRef**：部分支持年份参数，结合硬编码过滤
- **OpenReview**：不支持年份参数，依赖后续硬编码过滤

### 4.3 动态检索数量调整

系统根据约束条件动态调整检索数量：

```python
def calculate_retrieval_count(base_n_candidates, constraints=None, target_citations=50):
    """
    根据约束条件动态计算需要的检索数量
    """
    min_retrieval_count = target_citations * 6  # 至少300篇（50 * 6）
    
    # 根据约束严格程度调整
    multiplier = 1.0
    if constraints:
        if constraints.get('time_constraint'):
            multiplier += 0.5  # 时间约束增加50%
        if constraints.get('min_citations'):
            multiplier += 0.5  # 引用数约束增加50%
        if constraints.get('exclude_terms'):
            multiplier += 0.3  # 排除词增加30%
    
    adjusted_count = max(base_n_candidates, min_retrieval_count) * multiplier
    adjusted_count = min(adjusted_count, 800)  # 上限800篇
    
    return int(adjusted_count)
```

---

## 5. 预期难点与暂时解决方案

### 难点1：日期格式不一致

**问题描述**：
- 不同数据源的日期格式不同：`"2024-01-01"`、`"2024"`、`"Unknown"`、`None`
- 解析失败可能导致过滤错误

**解决方案**：
1. **统一解析函数**：使用 `parse_date_with_month()` 函数统一处理各种格式
2. **容错处理**：
   - 使用正则表达式提取年份：`re.search(r'\d{4}', date_str)`
   - 对于 `"Unknown"` 或 `None`，保留论文（避免过度过滤）
   - 对于无法解析的日期，输出警告但保留论文

---

### 难点2：约束提取的准确性

**问题描述**：
- 正则表达式可能误提取（如将 "2020 vision" 提取为年份）
- 可能漏提取（如复杂的表达方式）
- 提取的约束可能不完整

**解决方案**：
1. **多模式匹配**：
   - 使用多个正则表达式模式
   - 结合关键词匹配和模式匹配
   - 限制提取长度避免噪声（如年份限制在 1900-2100）

2. **保留原始 prompt**：
   - 在 `parsed_prompt` 中保存 `original_prompt`
   - 在生成阶段将原始 prompt 传递给 LLM
   - LLM 可以理解复杂表达并进行软过滤

---

### 难点3：过滤过度导致论文不足

**问题描述**：
- 硬编码过滤可能过滤过多论文
- 最终可用论文数量 < 50，无法满足引用多样性和全面性
- 用户约束过于严格

**解决方案**：
1. **日期未知保留**：
   - 对于 `publication_date == "Unknown"` 的论文，保留
   - 避免因日期缺失而过度过滤

2. **过滤后检查**：
   - 检查过滤后论文数量
   - 如果 < 原始数量的 10%，输出警告并放宽限制

3. **自动重试机制**：
   - 如果过滤后论文过少，自动放宽约束：
     - 降低 `min_citations`（如从 10 降到 5）
     - 移除部分 `exclude_terms`（保留最关键的）
   - 重新过滤原始论文列表

4. **动态检索调整**：
   - 根据约束严格程度增加初始检索数量(具体计算方式如###4.3动态检索调整)
   - 确保过滤后有足够候选论文

---

### 难点4：约束冲突

**问题描述**：
- 不同约束可能冲突：如 "latest" 与 "before 2020"
- 硬编码过滤与 LLM 软过滤可能产生不一致结果

**解决方案**：
1. **硬编码过滤优先**：
   - 对于明确的约束（年份、引用数），使用硬编码过滤
   - 确保进入后续流程的论文都符合硬约束

2. **软约束传递**：
   - 其他约束（如重点关注领域、特殊要求）通过 prompt 传递给 LLM
   - LLM 在生成内容时考虑这些约束，进行软过滤

3. **优先级规则**：
   - 硬约束（年份、引用数、排除词）> 软约束（重点关注、特殊要求）
   - 如果硬约束与软约束冲突，硬约束优先

---

### 难点5：API 限制

**问题描述**：
- 部分 API 不支持精确年份过滤（如 arXiv）
- API 返回的数据可能不完整（如缺少引用数）

**解决方案**：
1. **API 层面过滤**：
   - 对于支持年份参数的 API（如 OpenAlex），在调用时传递参数
   - 减少不相关论文的检索，提高效率

2. **硬编码过滤补充**：
   - 对于不支持年份参数的 API，检索后再用硬编码过滤
   - 确保所有数据源的结果都符合约束

3. **容错处理**：
   - API 调用失败时，输出错误但不中断流程
   - 使用其他数据源补充
   - 对于缺失的数据（如引用数），标记为未知(即原则上不过滤，保留)


---

## 6. 工作流程总结

### 6.1 完整流程

```
用户输入 Prompt
    ↓
parse_user_prompt() → 提取约束条件
    ↓
calculate_retrieval_count() → 根据约束调整检索数量
    ↓
search_multiple_sources() → 多源检索（API层面应用部分约束）
    ↓
filter_papers_by_constraints() → 硬编码过滤（年份、引用数、排除词）
    ↓
检查过滤后论文数量 → 不足时自动放宽约束并重试
    ↓
选择前50篇论文用于生成
    ↓
generate_plan() → 生成计划（约束转换为 requirements_text）
    ↓
generate_review() → 生成综述（约束转换为 requirements_text，强调50个引用）
    ↓
输出最终文献综述
```

### 6.2 关键参数

- **目标引用数**：50 个引用
- **目标字数**：1300-1700 words(这个可以视最后需要生成的review的长度而定再做调整，实际llm生成基本会在2000words)
- **Section 数量**：3 个主要 section(这个参数也可以再进行调整)
- **最小检索数量**：300 篇（50 * 6）
- **最大检索数量**：800 篇
- **用于生成的论文数**：50 篇

---

## 7. 相关作用文件

- `retrieval/src/integrated_workflow.py`：主要实现文件
  - `parse_user_prompt()`：约束提取函数
  - `filter_papers_by_constraints()`：硬编码过滤函数
  - `calculate_retrieval_count()`：动态检索数量计算
  - `generate_plan()` / `generate_review()`：生成函数（约束传递）

- `retrieval/src/single_query_retrieval.py`：单源检索实现

---